#!/bin/bash
# Packages all FetchContent dependencies from a CMake project for offline use.
#
# This script configures the CMake project in a temporary build directory,
# which triggers FetchContent to download all dependencies. It then copies
# all fetched *-src directories into an output package and generates a
# CMake preload file that sets FETCHCONTENT_SOURCE_DIR_* variables for
# each dependency, enabling fully offline builds.
#
# Usage: ./package_cmake_deps.sh [package_name]
#        OUTPUT_DIR=/path/to/output ./package_cmake_deps.sh [package_name]
set -euo pipefail

SOURCE_DIR="${PWD}"

# Parse arguments
NAME="${1:-offline}"
OUTPUT_DIR="${OUTPUT_DIR:-${SOURCE_DIR}/${NAME}_package}"
BUILD_DIR=$(mktemp -d)
trap "rm -rf ${BUILD_DIR}" EXIT

echo "=== Creating Package: ${NAME} ==="
echo "Source: ${SOURCE_DIR}"

rm -rf "${OUTPUT_DIR}"
mkdir -p "${OUTPUT_DIR}"

# Run cmake to fetch all dependencies
echo "Fetching dependencies via CMake..."
cmake -S "${SOURCE_DIR}" -B "${BUILD_DIR}" -DUSE_FORCE_FETCH=ON

# Remove .git directories from build dir
find "${BUILD_DIR}" -type d \( -name '.git' -o -name '.github' \) -exec rm -rf {} + 2>/dev/null || true

# Find and copy all *-src directories
echo "Copying dependencies..."
declare -A copied_deps

while IFS= read -r src_dir; do
    name=$(basename "${src_dir}" | sed 's/-src$//')

    # Handle duplicates
    if [[ -v copied_deps["$name"] ]]; then
        if diff -rq --exclude='.git' "${copied_deps[$name]}" "${src_dir}" >/dev/null 2>&1; then
            echo "  ${name} (skipped, duplicate)"
            continue
        else
            echo "ERROR: Duplicate dependency '${name}' with different content:"
            echo "  First:  ${copied_deps[$name]}"
            echo "  Second: ${src_dir}"
            exit 1
        fi
    fi

    echo "  ${name}"
    cp -r "${src_dir}" "${OUTPUT_DIR}/${name}"
    copied_deps["$name"]="${src_dir}"
done < <(find "${BUILD_DIR}" -type d -name "*-src" ! -path "*/CMakeFiles/*" -path "*/_deps/*" 2>/dev/null)

# Check if any deps were found
if [[ ${#copied_deps[@]} -eq 0 ]]; then
    echo "ERROR: No dependencies found"
    exit 1
fi

# Generate preload cmake file
PRELOAD_FILE="${OUTPUT_DIR}/${NAME}_preload.cmake"
echo "Generating ${NAME}_preload.cmake..."
{
    printf '# Autogenerated preload for %s\n' "${NAME}"

    for name in $(printf '%s\n' "${!copied_deps[@]}" | sort); do
        upper_name=$(echo "${name}" | tr '[:lower:]' '[:upper:]')
        printf 'set(FETCHCONTENT_SOURCE_DIR_%s "${CMAKE_CURRENT_LIST_DIR}/%s" CACHE PATH "")\n' "${upper_name}" "${name}"
    done

    printf '\nset(FETCHCONTENT_FULLY_DISCONNECTED ON CACHE BOOL "")\n'
    printf 'set(USE_FORCE_FETCH ON CACHE BOOL "")\n'
} >"${PRELOAD_FILE}"

echo "=== Done ==="
echo "Copied ${#copied_deps[@]} dependencies to: ${OUTPUT_DIR}"
echo "Preload file: ${PRELOAD_FILE}"
echo ""
echo "Usage: cmake -C ${PRELOAD_FILE} ..."
